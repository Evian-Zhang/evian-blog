本系列文章以我的个人博客的搭建为线索（GitHub 仓库：[Evian-Zhang/evian-blog](https://github.com/Evian-Zhang/evian-blog)），记录我在现代化程序设计中的一些笔记。在这篇文章中，我将介绍的是泛型与多态。

# 共性与标准

我们为什么要使用泛型与多态？这些诡异的中文译名究竟指的是什么？我觉得，要解释这个问题，就需要指出我们实际编写项目时需要的共性与标准。

假设我们在编写一个快餐店的程序。快餐店中，有服务员、薯条厨师、汉堡厨师和炸鸡厨师，在我们的程序中，这每一个职业都被实现为一个类，这个思路是很自然的。每个职业除了都有自己个性的工作，比如说服务员端菜、薯条厨师炸薯条，还应该有一些共性的事。比如说，这些职业都是我们这个快餐店的员工，所以需要发工资。我们发工资的工序很简单，先看这个员工这个月请了多少天的假，再根据上班天数发对应职业的工资。也就是：

1. 查看这个员工这个月请假次数
2. 查看这个员工的工资标准
3. 发工资

无论是什么员工，发工资的操作总是类似的，这就是**共性**。同时，每个员工，我都应该有能力查看他的请假次数和工资标准，只有能够满足这样要求的人，才能成为发工资的对象，这就是**标准**。为了共性和标准，我们希望在编写代码的时候能满足两个条件：

* 同样的工序不写多次
* 只有符合条件的才能调用函数

也就是说，我希望我写的函数不能只给一个特定的对象用，因为还有很多和它有共性的对象能一起用；但是，我写的函数也不能谁都用，只有满足特定条件的对象才能用。这就是泛型与多态的目的。

具体而言，我有如下的类：

```rust
struct Waiter;
struct ChipsCook;
struct HamburgerCook;
struct ChickenCook;
```

我需要什么呢？我需要的是一个用来描述它们共性的标准，在Rust中，就是trait（在别的语言中可以是接口或基类，但在理解上没有什么区别）：

```rust
trait Employee {
    fn absence_days() -> usize;
    fn wage_level() -> usize;
}
```

我们需要提供这样一个接口，然后让每一个类去实现它：

```rust
impl Waiter for Employee {
    fn absence_days() -> usize { /* hide */ }
    fn wage_level() -> usize { /* hide */ }
}
```

像这样对`Waiter`, `ChipsCook`, `HamburgerCook`, `ChickenCook`都需要实现这样的接口，就表示这些类都是我们快餐店的员工，这就是解决了“标准”的问题。

接下来，就是解决共性的问题，怎样只写一次代码，却能对我们快餐店的员工都通用呢？

# 静态分派与动态分派

直觉告诉我们，我们应该写一个类似这样的函数（先不管语法）：

```rust
fn pay(employee: Employee) {
    let absence_days = employee.absence_days();
    let wage_level = employee.wage_level();
    // do something else
}
```

这么做显然是符合逻辑的。首先，我们需要的是快餐店员工，不是快餐店员工的人不能使用这个函数。然后，我们需要查看他请假天数和薪资标准，由于我们的几个职业都实现了这个接口，所以我们可以调用这些函数了。这看上去很简单，之前的步骤也很符合我们的逻辑。但是，仔细看，「我们就可以调用这些函数了」，究竟是怎么调用？

我们知道，函数实际上就是一个代码段，我们要调用函数，就是告诉CPU从某个地址开始执行相应的代码。然而，对于不同的职业，它的`absence_days`都是不同的，CPU怎么知道该执行谁的代码？这就涉及到了静态分派与动态分派的问题。

最简单的，在编译期，编译器是知道类型信息的。比如说我们这样调用：

```rust
let waiter = Waiter { };
pay(waiter);
```

编译器既然知道它调用的是什么类型，那么有没有办法给它指定呢？答案是像这样：

```rust
fn pay<E: Employee>(employer: T) { /* ... */ }

let waiter = Waiter { };
pay(waiter);
```

编译器实际做了啥事呢？我们可以理解成，当它看到我们调用了`pay(waiter)`，并且`waiter`已知的类型是符合我们传参的要求时，就为`Waiter`类型生成一个函数

```rust
fn pay(employee: Waiter) { /* ... */ }
```

这样的话，CPU自然就可以知道该调用哪个函数了，因为`Waiter`的`absence_days`只有一个。这种在编译期就确定的手法就叫作静态分派。

然而，有的时候并不遂人意，我们并不能在编译期确定所有的类型。我们想要给目前离我们最近的一个员工发工资，假设我们就用了一个`get_most_close_employee`函数，来获得目前离我们最近的一个员工。由于这样的员工有可能是任意一个职业，所以这个函数返回的，可能是任何一个快餐店员工的职业。用Rust的语言来说，我们得这样：

```rust
fn get_most_close_employee() -> Box<dyn Employee> { /* ... */ }
fn pay(employee: Box<dyn Employee>) { /* ... */ }

let employee = get_most_close_employee();
pay(employee);
```

由于Rust的限制，我们只能把这样动态返回类型的函数的返回值放在`Box`里。我们通过加上`dyn`关键字，就能实现一个动态类型了。那么编译器要做什么呢？编译器就没刚刚做的那么复杂了，直接把`Box`传递就好了，并不做什么生成代码的事。然而，CPU执行的时候，就会比较累了。执行的代码我们之前说过，并不能直接写一个函数地址，因为有多个函数。然而我们在生成这样地址的时候，也就是编译期，仍然不知道准确的类型，也就不知道应该生成的是哪个函数的地址。因此，大多数语言中都会对这类关系生成一个虚函数表，需要确定执行哪个函数的时候，只需要查表即可，这就是动态分派。

也就是说，由于在CPU执行的时候是没有类型信息的，所以静态分派和动态分派分别是这样的情形：

在静态分派的情况下，CPU坐在店里，这时一个对象进来了，并且身上写了需要CPU执行的函数，CPU就直接执行了；在动态分配的情况下， CPU坐在店里，这时一个对象进来了，CPU问“我要执行你的xx函数，告诉我从哪开始执行”，对象指了指某个地方，然后CPU再执行。也就是说，在动态分派的情况下，CPU需要有一个询问——应答的过程，也就会产生一些性能上的损耗。但是，动态分派也更加灵活一些。