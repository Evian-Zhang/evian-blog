本系列文章以我的个人博客的搭建为线索（GitHub 仓库：[Evian-Zhang/evian-blog](https://github.com/Evian-Zhang/evian-blog)），记录我在现代化程序设计中的一些笔记。在这篇文章中，我将从数字签名与证书开始，逐一介绍Web端、iOS端和Android端App的可信安全机制。

# 不止于保密的三大问题

我们知道，在现代科技领域，安全与密码学紧密相关。如果我们需要保证一个产品的安全，那么一定会去求助于密码学的工具。那么，密码学解决的究竟是什么问题？

## 保密

最基本的，密码学是为了保密。Alice和Bob在大庭广众下通信，但仍然不希望他人知道他们俩谈的内容，那么密码学就帮助他们对通信的内容进行加密，达到这样的目的。

在保密这个领域，密码学有两个武器：对称加密与非对称加密。

对称加密就是Alice和Bob在通信之前，掌握一个相同的密钥K。Alice说话之前，把想说的话m用K进行加密，成密文c。Bob收到c以后，用相同的K进行解密，得到Alice想说的话m。这个想法是很自然的，也能做的十分安全。但是，这种方案要求Alice和Bob要提前获得共享的密钥K，如果没有可靠的，不会被他人监听的信道，又怎么能传输K呢？这时我们来看看非对称加密。

非对称加密就是Alice生成了一个公钥P，一个私钥S。Alice将自己的公钥P广播给所有人，然后用私钥S加密自己的消息m，得到密文c。Bob用Alice广播的P对c进行解密，得到Alice想说的明文m。也就是说，密码学家运用超群的智慧，想出了一些算法，保证由公钥P得不到私钥S，同时由私钥加密的消息能用公钥进行解密。这就是非对称加密。

看上去非对称加密完全不需要Alice和Bob事先通过安全的信道共享密钥，那为什么还需要对称密钥呢？这是因为，非对称加密的算法很复杂，加密、解密一次的时间太长，如果要实时加密通信，那么完全不能用非对称加密。总之就是，对称加密快，但是需要事先用安全信道传输密钥；非对称加密不需要安全信道，但是慢。

## 保密之外的三大问题

除了保密之外，密码学还能解决什么问题呢？现在密码学一般还需要负责另外三个问题：

* 真实性(Authenticity)
* 完整性(Integrity)
* 不可否认性(Non-repudiation)

Bob收到了Alice发的一条消息，那么真实性就是Bob需要确定这消息确实是Alice发的，完整性就是Bob需要确定Alice发的确实是这条消息，没有得到篡改，不可否认性就是如果Alice说这条消息不是他发的，那么Bob需要向第三方证明这条消息确实是Alice发的。

真实性和不可否认性看上去似乎差不多，其区别在于，Bob可能可以通过一些只有自己知道的信息确认这是Alice发的，比如说，Alice在消息中说，Bob生日是1919年8月10号，那么Bob知道只有Alice知道这个秘密，所以真实性得到了保证。但如果Alice否认了这个消息，Bob向法官说，只有Alice知道自己的生日是1919年8月10号，但法官说我怎么知道你生日真的是1919年8月10号，所以这就不能保证不可否认性。

密码学里有分别解决这三个问题的武器，但我们直接来最厉害的，一次性解决这三个问题的武器——数字签名证书。

首先，我们要感谢密码学家，他们帮我们想到了一些精妙绝伦的算法，称为数字签名算法。非对称数字签名算法和非对称加密类似，也是Alice生成一个公钥P和私钥S，然后用S和这个算法对明文m做一些处理得到c。但是，非对称数字签名算法并不要求Bob用P能从c还原出m，而是根据m和P，判断这个c是不是用正确的私钥S加密的。这就像现实生活中的签名一样，能够判断这究竟是不是Alice说的。在这种情况下，通过私钥对明文进行数字签名后得到的c，一般称为消息验证码(MAC)。

通过数字签名算法，我们有效地解决了真实性和完整性。因为私钥只有Alice有，所以只要我们用Alice的公钥判断成功，那么这消息肯定是Alice发的。而数字签名算法又保证了，只要你稍微改动一点点原来的消息m，那么得到的MAC值则会产生巨大的改变。因此，我们也能顺利地判断完整性。

但是，不可否认性并不能解决。Alice否认了，我们拿着Alice的公钥去找法官，法官说，我怎么知道这就是Alice的公钥，说不定是你随便找的呢。因此，我们需要更近一层，使用数字签名证书。

Bob跟Alice说，如果你以后再发消息，首先，你要去找村口曹安，他童叟无欺，大家都信任他，让他给你的公钥打上标记，这样我再拿着你的公钥去找法官，法官见到曹安的标记，就会相信这个公钥是Alice的了。这就是数字签名证书的最核心的原理。

数字签名证书首先需要一个可信第三方，大家一般称他为CA(~~Cao An(划)~~Certificate Authority)。整体过程为：

1. CA自己产生一个公钥PA和一个私钥SA。
2. CA把PA分发给全村所有人，然后私钥自己保存好，一旦丢失就gg了。
3. Alice产生一个公钥P和一个私钥S
4. Alice把自己的相关信息写成一个证书，有自己的公钥P，自己的姓名Alice，还有一些其他信息，然后交给CA去签名。
5. CA用自己的私钥SA对这个证书签名。
6. 之后，Alice就爽了。他每次发消息给Bob的时候，一共提供三个东西：原文m，消息验证码c，CA签名的证书。

Bob一拿到Alice发的信息会干这些事：

1. 首先先拿CA之前发给自己的公钥PA，验证这个证书是不是CA签名的。
2. 如果证书是CA签名的话，从证书中获得Alice的公钥P。
3. 拿Alice的公钥P和原文m，消息验证码c，判断这个消息有没有通过数字签名验证算法。

我们之前说过，单纯的消息验证码就可以保证真实性和完整性，然后又由于CA大家都相信他，并且他的私钥不能被别人伪造，所以Alice无法否认这个消息确实是他发的。

当然，如果曹安是隔壁村的，但大家依然信任他，我们不能每个人都跑大老远去找他来签名自己的证书，曹安也会累。所以，我们就在我们村找个人叫陈昂（大家就叫他CA2），让他去找曹安签名自己的证书，得到CA2的证书。然后接下来我们村的人就不用找曹安来签名我们的证书了，直接找陈昂。当验证Alice证书的时候，我们首先根据获得的曹安的公钥，验证陈昂的证书确实是真的，再拿陈昂CA2证书里的公钥验证Alice的证书。也就是说，Alice发消息的时候，会发自己的原文m，消息验证码c，陈昂的证书，Alice的证书。这种过程可以一直延续下去，由根CA逐级签名，由曹安签陈昂的证书，陈昂签蔡艾的证书，一个接着一个，这就叫证书链。

有了这么强大的武器，我们接下来就用在实战中。

# HTTPS

首先我们来看Web应用的可信安全机制。我们日常在使用浏览器时，会有什么安全需求呢？纵观我们之前讲到的保密性，和保密之外的其他三个需求，我们发现，是都是需要的，也就是说：

* 保密性
* 真实性
* 完整性
* 不可否认性

我们都需要。这是因为，当我们输入网址，想要查看某个网站的时候，需要这个网站确实是由相应的服务器发出，而不是别人假扮的，并且内容也不能得到篡改，所以真实性、完整性、不可否认性我们都是需要的。同时，我们浏览什么网站，在网站上输入的用户名和密码，都不希望别人知道，所以，保密性也是需要的。

